# JavaScript関数定義パターン 詳細解説

このドキュメントでは、JavaScript関数抽出ツールが検出する各関数定義パターンについて、詳細な解説と実用例を提供します。

---

## 目次

1. [関数宣言（Function Declaration）](#1-関数宣言function-declaration)
2. [非同期関数宣言（Async Function Declaration）](#2-非同期関数宣言async-function-declaration)
3. [ジェネレータ関数宣言（Generator Function Declaration）](#3-ジェネレータ関数宣言generator-function-declaration)
4. [関数式（Function Expression）](#4-関数式function-expression)
5. [非同期関数式（Async Function Expression）](#5-非同期関数式async-function-expression)
6. [ジェネレータ関数式（Generator Function Expression）](#6-ジェネレータ関数式generator-function-expression)
7. [アロー関数（Arrow Function）](#7-アロー関数arrow-function)
8. [非同期アロー関数（Async Arrow Function）](#8-非同期アロー関数async-arrow-function)
9. [メソッド定義（Method Definition）](#9-メソッド定義method-definition)

---

## 1. 関数宣言（Function Declaration）

### 概要
最も基本的な関数定義方法。`function`キーワードを使用して関数を宣言します。

### 構文
```javascript
function 関数名(引数1, 引数2, ...) {
    // 関数本体
}
```

### 検出パターン
- **正規表現**: `r'function\s+(\w+)\s*\(([^)]*)\)'`
- **検出される型**: `function`

### 使用される場合

#### 1.1 一般的な関数定義
最も基本的な用途。再利用可能なコードブロックを定義する際に使用されます。

```javascript
function greet(name) {
    return `Hello, ${name}!`;
}

function calculateSum(a, b) {
    return a + b;
}
```

#### 1.2 再帰関数
自分自身を呼び出す関数。階乗計算やツリー構造の走査などで使用されます。

```javascript
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

function traverseTree(node) {
    console.log(node.value);
    if (node.children) {
        node.children.forEach(child => traverseTree(child));
    }
}
```

#### 1.3 ホイスティングを利用した関数
関数宣言はホイスティングされるため、定義前に呼び出すことができます。

```javascript
// 関数定義の前に呼び出し可能
sayHello(); // "Hello!" が出力される

function sayHello() {
    console.log("Hello!");
}
```

#### 1.4 名前空間としての関数
関数内に関数を定義して、名前空間として使用します。

```javascript
function Utils() {
    function formatDate(date) {
        return date.toISOString();
    }
    
    function formatCurrency(amount) {
        return `$${amount.toFixed(2)}`;
    }
    
    return { formatDate, formatCurrency };
}
```

### 特徴
- ✅ ホイスティングされる（定義前に呼び出し可能）
- ✅ 関数名が必須
- ✅ ブロックスコープを持つ
- ✅ `this`の値は呼び出し方法によって決まる

### 検出例
```javascript
function processData(data, options) {
    // 処理
}
```
**検出結果**:
- 型: `function`
- 関数名: `processData`
- 引数: `['data', 'options']`

---

## 2. 非同期関数宣言（Async Function Declaration）

### 概要
`async`キーワードを使用した非同期関数。`await`キーワードを使用して非同期処理を同期的に記述できます。

### 構文
```javascript
async function 関数名(引数1, 引数2, ...) {
    // 関数本体
    await 非同期処理();
}
```

### 検出パターン
- **正規表現**: `r'async\s+function\s+(\w+)\s*\(([^)]*)\)'`
- **検出される型**: `async_function`

### 使用される場合

#### 2.1 API呼び出し
HTTPリクエストやデータベースアクセスなどの非同期処理で使用されます。

```javascript
async function fetchUserData(userId) {
    const response = await fetch(`/api/users/${userId}`);
    const userData = await response.json();
    return userData;
}

async function saveToDatabase(data) {
    const connection = await getDatabaseConnection();
    await connection.insert(data);
    await connection.close();
}
```

#### 2.2 複数の非同期処理の順次実行
複数の非同期処理を順番に実行する場合に使用します。

```javascript
async function processFiles(files) {
    const results = [];
    for (const file of files) {
        const content = await readFile(file);
        const processed = await processContent(content);
        results.push(processed);
    }
    return results;
}
```

#### 2.3 エラーハンドリング
`try-catch`ブロックで非同期処理のエラーを処理します。

```javascript
async function safeApiCall(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('API呼び出しエラー:', error);
        return null;
    }
}
```

### 特徴
- ✅ 常にPromiseを返す
- ✅ `await`キーワードを使用可能
- ✅ エラーハンドリングが容易
- ✅ 非同期処理を同期的に記述できる

### 検出例
```javascript
async function loadUserProfile(userId) {
    const user = await fetchUser(userId);
    const posts = await fetchUserPosts(userId);
    return { user, posts };
}
```
**検出結果**:
- 型: `async_function`
- 関数名: `loadUserProfile`
- 引数: `['userId']`

---

## 3. ジェネレータ関数宣言（Generator Function Declaration）

### 概要
`function*`構文を使用したジェネレータ関数。`yield`キーワードで値を返し、次回呼び出し時に処理を再開できます。

### 構文
```javascript
function* 関数名(引数1, 引数2, ...) {
    yield 値1;
    yield 値2;
    // ...
}
```

### 検出パターン
- **正規表現**: `r'function\s*\*\s*(\w+)\s*\(([^)]*)\)'`
- **検出される型**: `generator_function`

### 使用される場合

#### 3.1 イテレータの作成
カスタムイテレータを作成する際に使用します。

```javascript
function* numberRange(start, end) {
    for (let i = start; i <= end; i++) {
        yield i;
    }
}

// 使用例
for (const num of numberRange(1, 5)) {
    console.log(num); // 1, 2, 3, 4, 5
}
```

#### 3.2 無限シーケンス
無限に続くシーケンスを生成する場合に使用します。

```javascript
function* fibonacci() {
    let a = 0, b = 1;
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

// 使用例
const fib = fibonacci();
console.log(fib.next().value); // 0
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
```

#### 3.3 遅延評価
必要な時だけ値を計算する遅延評価に使用します。

```javascript
function* lazyMap(array, mapper) {
    for (const item of array) {
        yield mapper(item);
    }
}

// 使用例
const numbers = [1, 2, 3, 4, 5];
const doubled = lazyMap(numbers, x => x * 2);
// 実際に値が必要になるまで計算されない
```

#### 3.4 状態管理
関数の状態を保持しながら処理を進める場合に使用します。

```javascript
function* stateMachine() {
    let state = 'idle';
    while (true) {
        const action = yield state;
        switch (action) {
            case 'start':
                state = 'running';
                break;
            case 'stop':
                state = 'stopped';
                break;
            case 'reset':
                state = 'idle';
                break;
        }
    }
}
```

### 特徴
- ✅ `yield`で値を返す
- ✅ 呼び出しごとに処理を再開
- ✅ メモリ効率が良い（必要な時だけ計算）
- ✅ イテレータプロトコルを実装

### 検出例
```javascript
function* generateIds(prefix) {
    let counter = 1;
    while (true) {
        yield `${prefix}-${counter++}`;
    }
}
```
**検出結果**:
- 型: `generator_function`
- 関数名: `generateIds`
- 引数: `['prefix']`

---

## 4. 関数式（Function Expression）

### 概要
変数に代入する形で関数を定義します。関数名は省略可能（無名関数）です。

### 構文
```javascript
const/let/var 変数名 = function(引数1, 引数2, ...) {
    // 関数本体
};
```

### 検出パターン
- **正規表現**: `r'(?:const|let|var)\s+(\w+)\s*=\s*function\s*\(([^)]*)\)'`
- **検出される型**: `function_expression`

### 使用される場合

#### 4.1 変数に関数を代入
関数を変数として扱い、後から変更可能にします。

```javascript
const multiply = function(a, b) {
    return a * b;
};

let operation = function(x, y) {
    return x + y;
};

// 後から変更可能
operation = function(x, y) {
    return x * y;
};
```

#### 4.2 条件付き関数定義
条件に応じて異なる関数を代入します。

```javascript
let processData;
if (environment === 'production') {
    processData = function(data) {
        return data.map(item => item.toUpperCase());
    };
} else {
    processData = function(data) {
        console.log('Processing:', data);
        return data;
    };
}
```

#### 4.3 コールバック関数として使用
他の関数に引数として渡す関数を定義します。

```javascript
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(function(n) {
    return n * 2;
});

const filtered = numbers.filter(function(n) {
    return n % 2 === 0;
});
```

#### 4.4 即時実行関数（IIFE）の一部
即座に実行される関数式の一部として使用します。

```javascript
(function() {
    const privateVariable = 'secret';
    
    window.publicFunction = function() {
        return privateVariable;
    };
})();
```

### 特徴
- ✅ ホイスティングされない（定義前に呼び出し不可）
- ✅ 変数スコープに従う
- ✅ 関数名を省略可能（無名関数）
- ✅ 後から変更可能（`let`/`var`の場合）

### 検出例
```javascript
const calculate = function(x, y, operation) {
    switch(operation) {
        case 'add': return x + y;
        case 'subtract': return x - y;
        default: return 0;
    }
};
```
**検出結果**:
- 型: `function_expression`
- 関数名: `calculate`
- 引数: `['x', 'y', 'operation']`

---

## 5. 非同期関数式（Async Function Expression）

### 概要
関数式の非同期版。`async function`を変数に代入します。

### 構文
```javascript
const/let/var 変数名 = async function(引数1, 引数2, ...) {
    await 非同期処理();
};
```

### 検出パターン
- **正規表現**: `r'(?:const|let|var)\s+(\w+)\s*=\s*async\s+function\s*\(([^)]*)\)'`
- **検出される型**: `async_function_expression`

### 使用される場合

#### 5.1 動的な非同期処理の定義
実行時に非同期関数を定義する場合に使用します。

```javascript
const loadData = async function(path) {
    const data = await import(path);
    return data.default;
};

// 使用例
const module = await loadData('./utils.js');
```

#### 5.2 条件付き非同期処理
条件に応じて異なる非同期処理を定義します。

```javascript
let fetchData;
if (useCache) {
    fetchData = async function(url) {
        const cached = await getFromCache(url);
        if (cached) return cached;
        const data = await fetch(url).then(r => r.json());
        await saveToCache(url, data);
        return data;
    };
} else {
    fetchData = async function(url) {
        return await fetch(url).then(r => r.json());
    };
}
```

#### 5.3 非同期コールバック
非同期処理をコールバックとして使用します。

```javascript
const processItems = async function(items) {
    const results = [];
    for (const item of items) {
        const processed = await async function(item) {
            // 非同期処理
            return await processItem(item);
        }(item);
        results.push(processed);
    }
    return results;
};
```

### 特徴
- ✅ 関数式の特徴を継承
- ✅ 非同期処理を同期的に記述可能
- ✅ 動的な定義が可能

### 検出例
```javascript
const loadUser = async function(userId) {
    const response = await fetch(`/api/users/${userId}`);
    return await response.json();
};
```
**検出結果**:
- 型: `async_function_expression`
- 関数名: `loadUser`
- 引数: `['userId']`

---

## 6. ジェネレータ関数式（Generator Function Expression）

### 概要
関数式のジェネレータ版。`function*`を変数に代入します。

### 構文
```javascript
const/let/var 変数名 = function*(引数1, 引数2, ...) {
    yield 値;
};
```

### 検出パターン
- **正規表現**: `r'(?:const|let|var)\s+(\w+)\s*=\s*function\s*\*\s*\(([^)]*)\)'`
- **検出される型**: `generator_function_expression`

### 使用される場合

#### 6.1 動的なジェネレータ作成
実行時にジェネレータ関数を定義します。

```javascript
const createCounter = function*(start) {
    let current = start;
    while (true) {
        yield current++;
    }
};

// 使用例
const counter = createCounter(10);
console.log(counter.next().value); // 10
console.log(counter.next().value); // 11
```

#### 6.2 ファクトリーパターン
異なるジェネレータを生成するファクトリー関数として使用します。

```javascript
const createRange = function*(start, end, step = 1) {
    for (let i = start; i <= end; i += step) {
        yield i;
    }
};

// 使用例
const evenNumbers = createRange(0, 10, 2);
for (const num of evenNumbers) {
    console.log(num); // 0, 2, 4, 6, 8, 10
}
```

### 特徴
- ✅ 関数式の特徴を継承
- ✅ ジェネレータの機能を持つ
- ✅ 動的な定義が可能

### 検出例
```javascript
const fibonacci = function* (n) {
    let a = 0, b = 1;
    for (let i = 0; i < n; i++) {
        yield a;
        [a, b] = [b, a + b];
    }
};
```
**検出結果**:
- 型: `generator_function_expression`
- 関数名: `fibonacci`
- 引数: `['n']`

---

## 7. アロー関数（Arrow Function）

### 概要
ES6で導入された簡潔な関数記法。`=>`を使用して関数を定義します。

### 構文
```javascript
const/let/var 変数名 = (引数1, 引数2, ...) => {
    // 関数本体
};

// 単一式の場合は波括弧とreturnを省略可能
const/let/var 変数名 = (引数1, 引数2, ...) => 式;
```

### 検出パターン
- **正規表現**: `r'(?:const|let|var)\s+(\w+)\s*=\s*\(([^)]*)\)\s*=>'`
- **検出される型**: `arrow_function`

### 使用される場合

#### 7.1 配列メソッドのコールバック
`map`、`filter`、`reduce`などの配列メソッドでよく使用されます。

```javascript
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
const sum = numbers.reduce((acc, n) => acc + n, 0);
```

#### 7.2 短い関数の定義
簡潔に記述できるため、短い関数の定義に適しています。

```javascript
const add = (a, b) => a + b;
const square = x => x * x;
const greet = name => `Hello, ${name}!`;
```

#### 7.3 `this`のバインディング
アロー関数は`this`をレキシカルにバインドするため、コールバックで`this`を保持したい場合に使用します。

```javascript
class Button {
    constructor(element) {
        this.element = element;
        this.clickCount = 0;
    }
    
    setupClickHandler() {
        // アロー関数を使用することで、thisがButtonインスタンスを指す
        this.element.addEventListener('click', () => {
            this.clickCount++;
            console.log(`Clicked ${this.clickCount} times`);
        });
    }
}
```

#### 7.4 関数の返り値として使用
関数が関数を返す高階関数で使用されます。

```javascript
const createMultiplier = (factor) => (number) => number * factor;

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

#### 7.5 デフォルト引数との組み合わせ
デフォルト引数と組み合わせて使用します。

```javascript
const createUser = (name, age = 18, city = 'Tokyo') => ({
    name,
    age,
    city
});

const user1 = createUser('Alice'); // { name: 'Alice', age: 18, city: 'Tokyo' }
const user2 = createUser('Bob', 25); // { name: 'Bob', age: 25, city: 'Tokyo' }
```

### 特徴
- ✅ 簡潔な記法
- ✅ `this`をレキシカルにバインド
- ✅ `arguments`オブジェクトを持たない
- ✅ コンストラクタとして使用不可
- ✅ ホイスティングされない

### 検出例
```javascript
const processData = (data, transform) => {
    return data.map(item => transform(item));
};
```
**検出結果**:
- 型: `arrow_function`
- 関数名: `processData`
- 引数: `['data', 'transform']`

**注意**: この例では、`map`内のアロー関数（`item => transform(item)`）は検出されません。変数に代入されていないためです。

---

## 8. 非同期アロー関数（Async Arrow Function）

### 概要
アロー関数の非同期版。`async`キーワードと`=>`を組み合わせます。

### 構文
```javascript
const/let/var 変数名 = async (引数1, 引数2, ...) => {
    await 非同期処理();
};
```

### 検出パターン
- **正規表現**: `r'(?:const|let|var)\s+(\w+)\s*=\s*async\s+\(([^)]*)\)\s*=>'`
- **検出される型**: `async_arrow_function`

### 使用される場合

#### 8.1 非同期コールバック
非同期処理をコールバックとして使用する場合に使用します。

```javascript
const fetchUser = async (userId) => {
    const response = await fetch(`/api/users/${userId}`);
    return await response.json();
};

// 使用例
const userIds = [1, 2, 3];
const users = await Promise.all(
    userIds.map(id => fetchUser(id))
);
```

#### 8.2 イベントハンドラー
非同期処理を含むイベントハンドラーで使用します。

```javascript
button.addEventListener('click', async (event) => {
    event.preventDefault();
    const data = await fetchData();
    updateUI(data);
});
```

#### 8.3 配列の非同期処理
配列の各要素に対して非同期処理を実行する場合に使用します。

```javascript
const processItems = async (items) => {
    const results = await Promise.all(
        items.map(async (item) => {
            const processed = await processItem(item);
            return processed;
        })
    );
    return results;
};
```

#### 8.4 短い非同期関数
簡潔に非同期関数を定義する場合に使用します。

```javascript
const loadConfig = async () => {
    const response = await fetch('/config.json');
    return await response.json();
};

const saveData = async (data) => {
    await fetch('/api/save', {
        method: 'POST',
        body: JSON.stringify(data)
    });
};
```

### 特徴
- ✅ アロー関数の簡潔さ
- ✅ 非同期処理を同期的に記述可能
- ✅ `this`をレキシカルにバインド

### 検出例
```javascript
const fetchUserPosts = async (userId) => {
    const user = await fetchUser(userId);
    const posts = await fetchUserPosts(userId);
    return { user, posts };
};
```
**検出結果**:
- 型: `async_arrow_function`
- 関数名: `fetchUserPosts`
- 引数: `['userId']`

---

## 9. メソッド定義（Method Definition）

### 概要
ES6で導入されたオブジェクトリテラルやクラス内でのメソッド定義の簡潔な記法。

### 構文
```javascript
// オブジェクトリテラル内
const obj = {
    メソッド名(引数1, 引数2, ...) {
        // メソッド本体
    }
};

// クラス内
class ClassName {
    メソッド名(引数1, 引数2, ...) {
        // メソッド本体
    }
}
```

### 検出パターン
- **正規表現**: `r'(\w+)\s*\(([^)]*)\)\s*\{'`
- **検出される型**: `method`

### 使用される場合

#### 9.1 オブジェクトリテラル内のメソッド
オブジェクトリテラル内でメソッドを定義します。

```javascript
const calculator = {
    add(a, b) {
        return a + b;
    },
    
    subtract(a, b) {
        return a - b;
    },
    
    multiply(a, b) {
        return a * b;
    },
    
    divide(a, b) {
        if (b === 0) {
            throw new Error('Division by zero');
        }
        return a / b;
    }
};

// 使用例
console.log(calculator.add(5, 3)); // 8
console.log(calculator.multiply(4, 7)); // 28
```

#### 9.2 クラス内のメソッド
クラス内でインスタンスメソッドを定義します。

```javascript
class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }
    
    getName() {
        return this.name;
    }
    
    setEmail(newEmail) {
        this.email = newEmail;
    }
    
    getProfile() {
        return {
            name: this.name,
            email: this.email
        };
    }
}
```

#### 9.3 静的メソッド
クラスの静的メソッドを定義します。

```javascript
class MathUtils {
    static add(a, b) {
        return a + b;
    }
    
    static multiply(a, b) {
        return a * b;
    }
    
    static calculateAverage(numbers) {
        const sum = numbers.reduce((a, b) => a + b, 0);
        return sum / numbers.length;
    }
}

// 使用例
console.log(MathUtils.add(5, 3)); // 8
console.log(MathUtils.calculateAverage([1, 2, 3, 4, 5])); // 3
```

#### 9.4 ゲッター・セッター
オブジェクトのプロパティアクセスを制御します。

```javascript
const person = {
    _age: 0,
    
    get age() {
        return this._age;
    },
    
    set age(value) {
        if (value < 0) {
            throw new Error('Age cannot be negative');
        }
        this._age = value;
    }
};

// 使用例
person.age = 25;
console.log(person.age); // 25
```

#### 9.5 モジュールパターン
モジュールパターンでメソッドを定義します。

```javascript
const ApiClient = {
    baseUrl: 'https://api.example.com',
    
    async get(endpoint) {
        const response = await fetch(`${this.baseUrl}${endpoint}`);
        return await response.json();
    },
    
    async post(endpoint, data) {
        const response = await fetch(`${this.baseUrl}${endpoint}`, {
            method: 'POST',
            body: JSON.stringify(data)
        });
        return await response.json();
    }
};
```

### 誤検出の防止

このパターンは最も広範囲にマッチするため、誤検出を防ぐために以下のフィルタリングを行います：

#### 9.5.1 キーワードの除外
JavaScriptの予約語・キーワードを除外します。

```javascript
// 以下のようなパターンは検出されません
if (condition) { ... }      // 'if'はキーワード
for (let i = 0; i < 10; i++) { ... }  // 'for'はキーワード
while (condition) { ... }   // 'while'はキーワード
```

#### 9.5.2 前後の文字列の確認
オブジェクトリテラルやクラス内のメソッドかどうかを判定します。

```javascript
// 検出される
const obj = {
    method() { ... }  // オブジェクトリテラル内
};

class MyClass {
    method() { ... }   // クラス内
}

// 検出されない（通常の関数呼び出し）
someFunction();  // 関数呼び出し
obj.method();    // メソッド呼び出し
```

### 特徴
- ✅ 簡潔な記法（`function`キーワード不要）
- ✅ オブジェクトやクラス内での使用に適している
- ✅ `this`がオブジェクト/インスタンスを指す
- ⚠️ 誤検出の可能性があるため、フィルタリングが必要

### 検出例
```javascript
const userService = {
    async fetchUser(userId) {
        const response = await fetch(`/api/users/${userId}`);
        return await response.json();
    },
    
    updateUser(userId, data) {
        return fetch(`/api/users/${userId}`, {
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }
};
```
**検出結果**:
- 型: `method`
- 関数名: `fetchUser`, `updateUser`
- 引数: `['userId']`, `['userId', 'data']`

---

## パターン比較表

| パターン | ホイスティング | `this`のバインディング | コンストラクタ | 主な用途 |
|---------|--------------|---------------------|--------------|---------|
| 関数宣言 | ✅ あり | 動的 | ✅ 可 | 一般的な関数定義 |
| 非同期関数宣言 | ✅ あり | 動的 | ❌ 不可 | 非同期処理 |
| ジェネレータ関数宣言 | ✅ あり | 動的 | ❌ 不可 | イテレータ生成 |
| 関数式 | ❌ なし | 動的 | ✅ 可 | 変数への代入 |
| 非同期関数式 | ❌ なし | 動的 | ❌ 不可 | 非同期処理の変数代入 |
| ジェネレータ関数式 | ❌ なし | 動的 | ❌ 不可 | ジェネレータの変数代入 |
| アロー関数 | ❌ なし | レキシカル | ❌ 不可 | コールバック、短い関数 |
| 非同期アロー関数 | ❌ なし | レキシカル | ❌ 不可 | 非同期コールバック |
| メソッド定義 | ❌ なし | オブジェクト/インスタンス | ❌ 不可 | オブジェクト/クラスのメソッド |

---

## 検出されないパターン

以下のパターンは現在のツールでは検出されません：

### 1. 無名関数（変数に代入されていない）
```javascript
// 検出されない
array.map(function(item) { return item * 2; });
array.filter(item => item > 0);
```

### 2. 即時実行関数（IIFE）
```javascript
// 検出されない
(function() {
    // 処理
})();

(async () => {
    // 処理
})();
```

### 3. コンストラクタ関数
```javascript
// 検出されない（関数宣言として検出されるが、コンストラクタとしての用途は不明）
function Person(name) {
    this.name = name;
}
```

### 4. 関数内の関数（ネストされた関数）
```javascript
// 外側の関数は検出されるが、内側の関数も検出される
function outer() {
    function inner() {  // これも検出される
        // 処理
    }
    return inner;
}
```

---

## まとめ

このツールは、JavaScriptで使用される主要な関数定義パターンを検出できます。各パターンにはそれぞれ適した用途があり、プロジェクトの要件に応じて適切なパターンを選択することが重要です。

パターンの選択時には、以下の点を考慮してください：
- ホイスティングが必要か
- `this`のバインディング方法
- コードの簡潔さ
- 再利用性
- 非同期処理の有無

