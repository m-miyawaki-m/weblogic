# Javaメソッド定義パターン 詳細解説

このドキュメントでは、Javaメソッド抽出ツールが検出する各メソッド定義パターンについて、詳細な解説と実用例を提供します。

---

## 目次

1. [通常のメソッド定義（Method Definition）](#1-通常のメソッド定義method-definition)
2. [コンストラクタ（Constructor）](#2-コンストラクタconstructor)
3. [インターフェースメソッド（Interface Method）](#3-インターフェースメソッドinterface-method)

---

## 1. 通常のメソッド定義（Method Definition）

### 概要
Javaクラス内で定義される通常のメソッド。修飾子、戻り値の型、メソッド名、引数、メソッド本体で構成されます。

### 構文
```java
[修飾子] 戻り値の型 メソッド名(引数1, 引数2, ...) {
    // メソッド本体
}
```

### 検出パターン
- **正規表現**: `r'(?:(?:public|private|protected|static|final|abstract|synchronized|native|strictfp)\s+)*(void|[\w<>\[\]\s,\.]+?)\s+(\w+)\s*\(([^)]*)\)\s*\{'`
- **検出される型**: `method`

### 使用される場合

#### 1.1 基本的なメソッド定義

最も基本的な用途。クラス内で機能を実装する際に使用されます。

```java
public class User {
    private String name;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}
```

**検出結果**:
- `getName`: 型=`method`, 戻り値の型=`String`, 修飾子=`public`, 引数=`[]`
- `setName`: 型=`method`, 戻り値の型=`void`, 修飾子=`public`, 引数=`['String name']`

---

#### 1.2 静的メソッド（Static Method）

クラスに属するメソッドで、インスタンスを作成せずに呼び出せます。

```java
public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double calculateAverage(double[] numbers) {
        double sum = 0;
        for (double num : numbers) {
            sum += num;
        }
        return sum / numbers.length;
    }
}

// 使用例
int result = MathUtils.add(5, 3);
double avg = MathUtils.calculateAverage(new double[]{1.0, 2.0, 3.0});
```

**検出結果**:
- `add`: 型=`method`, 戻り値の型=`int`, 修飾子=`public, static`, 引数=`['int a', 'int b']`
- `calculateAverage`: 型=`method`, 戻り値の型=`double`, 修飾子=`public, static`, 引数=`['double[] numbers']`

---

#### 1.3 プライベートメソッド（Private Method）

クラス内部でのみ使用されるメソッド。カプセル化のために使用されます。

```java
public class BankAccount {
    private double balance;
    
    public void deposit(double amount) {
        if (validateAmount(amount)) {
            balance += amount;
        }
    }
    
    private boolean validateAmount(double amount) {
        return amount > 0;
    }
}
```

**検出結果**:
- `deposit`: 型=`method`, 戻り値の型=`void`, 修飾子=`public`, 引数=`['double amount']`
- `validateAmount`: 型=`method`, 戻り値の型=`boolean`, 修飾子=`private`, 引数=`['double amount']`

---

#### 1.4 保護されたメソッド（Protected Method）

同じパッケージ内またはサブクラスからアクセス可能なメソッド。

```java
public class Animal {
    protected String name;
    
    protected void makeSound() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    public void bark() {
        makeSound();  // 保護されたメソッドを呼び出し可能
    }
}
```

**検出結果**:
- `makeSound`: 型=`method`, 戻り値の型=`void`, 修飾子=`protected`, 引数=`[]`

---

#### 1.5 抽象メソッド（Abstract Method）

抽象クラス内で定義され、サブクラスで実装される必要があるメソッド。

```java
public abstract class Shape {
    protected String color;
    
    public abstract double calculateArea();
    
    public abstract double calculatePerimeter();
    
    public void setColor(String color) {
        this.color = color;
    }
}

public class Circle extends Shape {
    private double radius;
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}
```

**検出結果**:
- `calculateArea`: 型=`method`, 戻り値の型=`double`, 修飾子=`public, abstract`, 引数=`[]`
- `calculatePerimeter`: 型=`method`, 戻り値の型=`double`, 修飾子=`public, abstract`, 引数=`[]`
- `setColor`: 型=`method`, 戻り値の型=`void`, 修飾子=`public`, 引数=`['String color']`

---

#### 1.6 同期化メソッド（Synchronized Method）

マルチスレッド環境で排他制御を行うメソッド。

```java
public class Counter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
}
```

**検出結果**:
- `increment`: 型=`method`, 戻り値の型=`void`, 修飾子=`public, synchronized`, 引数=`[]`
- `getCount`: 型=`method`, 戻り値の型=`int`, 修飾子=`public, synchronized`, 引数=`[]`

---

#### 1.7 ネイティブメソッド（Native Method）

他の言語（通常はC/C++）で実装されたメソッド。

```java
public class NativeExample {
    public native void nativeMethod();
    
    static {
        System.loadLibrary("nativeLib");
    }
}
```

**検出結果**:
- `nativeMethod`: 型=`method`, 戻り値の型=`void`, 修飾子=`public, native`, 引数=`[]`

---

#### 1.8 finalメソッド（Final Method）

オーバーライドできないメソッド。

```java
public class Parent {
    public final void finalMethod() {
        System.out.println("This cannot be overridden");
    }
}

public class Child extends Parent {
    // コンパイルエラー: finalメソッドはオーバーライドできない
    // public void finalMethod() { }
}
```

**検出結果**:
- `finalMethod`: 型=`method`, 戻り値の型=`void`, 修飾子=`public, final`, 引数=`[]`

---

#### 1.9 strictfpメソッド（Strictfp Method）

浮動小数点演算の精度を厳密に制御するメソッド。

```java
public class MathCalculation {
    public strictfp double calculate(double a, double b) {
        return a * b / 3.0;
    }
}
```

**検出結果**:
- `calculate`: 型=`method`, 戻り値の型=`double`, 修飾子=`public, strictfp`, 引数=`['double a', 'double b']`

---

#### 1.10 複数の修飾子の組み合わせ

複数の修飾子を組み合わせて使用できます。

```java
public class Example {
    public static final int CONSTANT = 100;
    
    public static final void process() {
        // 処理
    }
    
    private static synchronized void internalProcess() {
        // 処理
    }
}
```

**検出結果**:
- `process`: 型=`method`, 戻り値の型=`void`, 修飾子=`public, static, final`, 引数=`[]`
- `internalProcess`: 型=`method`, 戻り値の型=`void`, 修飾子=`private, static, synchronized`, 引数=`[]`

---

#### 1.11 ジェネリクス型を返すメソッド

ジェネリクス型を戻り値として使用するメソッド。

```java
public class Repository<T> {
    private List<T> items = new ArrayList<>();
    
    public List<T> getAll() {
        return new ArrayList<>(items);
    }
    
    public Map<String, List<T>> getGrouped() {
        // 処理
        return new HashMap<>();
    }
}
```

**検出結果**:
- `getAll`: 型=`method`, 戻り値の型=`List<T>`, 修飾子=`public`, 引数=`[]`
- `getGrouped`: 型=`method`, 戻り値の型=`Map<String, List<T>>`, 修飾子=`public`, 引数=`[]`

---

#### 1.12 配列を返すメソッド

配列を戻り値として返すメソッド。

```java
public class ArrayUtils {
    public int[] getNumbers() {
        return new int[]{1, 2, 3, 4, 5};
    }
    
    public String[][] getMatrix() {
        return new String[10][10];
    }
}
```

**検出結果**:
- `getNumbers`: 型=`method`, 戻り値の型=`int[]`, 修飾子=`public`, 引数=`[]`
- `getMatrix`: 型=`method`, 戻り値の型=`String[][]`, 修飾子=`public`, 引数=`[]`

---

#### 1.13 可変長引数（Varargs）

可変数の引数を受け取るメソッド。

```java
public class VarargsExample {
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }
    
    public void printMessages(String... messages) {
        for (String msg : messages) {
            System.out.println(msg);
        }
    }
}

// 使用例
int result = sum(1, 2, 3, 4, 5);
printMessages("Hello", "World", "Java");
```

**検出結果**:
- `sum`: 型=`method`, 戻り値の型=`int`, 修飾子=`public`, 引数=`['int... numbers']`
- `printMessages`: 型=`method`, 戻り値の型=`void`, 修飾子=`public`, 引数=`['String... messages']`

---

#### 1.14 ジェネリクスメソッド

メソッドレベルでジェネリクスを使用するメソッド。

```java
public class GenericMethodExample {
    public <T> T getFirst(List<T> list) {
        return list.isEmpty() ? null : list.get(0);
    }
    
    public <K, V> Map<K, V> createMap(K key, V value) {
        Map<K, V> map = new HashMap<>();
        map.put(key, value);
        return map;
    }
}
```

**検出結果**:
- `getFirst`: 型=`method`, 戻り値の型=`T`, 修飾子=`public`, 引数=`['List<T> list']`
- `createMap`: 型=`method`, 戻り値の型=`Map<K, V>`, 修飾子=`public`, 引数=`['K key', 'V value']`

**注意**: ジェネリクス型パラメータ（`<T>`, `<K, V>`）は戻り値の型から除去されます。

---

#### 1.15 複雑な引数のメソッド

複雑な型の引数を受け取るメソッド。

```java
public class ComplexExample {
    public void processData(
        Map<String, List<Integer>> data,
        Set<String> keys,
        Consumer<String> callback
    ) {
        // 処理
    }
    
    public <T extends Comparable<T>> void sort(List<T> list) {
        Collections.sort(list);
    }
}
```

**検出結果**:
- `processData`: 型=`method`, 戻り値の型=`void`, 修飾子=`public`, 
  引数=`['Map<String, List<Integer>> data', 'Set<String> keys', 'Consumer<String> callback']`
- `sort`: 型=`method`, 戻り値の型=`void`, 修飾子=`public`, 引数=`['List<T> list']`

---

### 特徴
- ✅ 修飾子を複数指定可能
- ✅ 戻り値の型は必須（voidを含む）
- ✅ 引数は0個以上
- ✅ メソッド本体は波括弧で囲む
- ✅ オーバーロード可能（同じ名前で異なる引数）

---

## 2. コンストラクタ（Constructor）

### 概要
クラスのインスタンスを初期化するための特殊なメソッド。クラス名と同じ名前を持ち、戻り値の型はありません。

### 構文
```java
[修飾子] クラス名(引数1, 引数2, ...) {
    // 初期化処理
}
```

### 検出パターン
- **正規表現**: `r'(?:(?:public|private|protected)\s+)?(\w+)\s*\(([^)]*)\)\s*\{'`
- **検出される型**: `constructor`

### 使用される場合

#### 2.1 デフォルトコンストラクタ

引数なしのコンストラクタ。明示的に定義しない場合、コンパイラが自動生成します。

```java
public class User {
    private String name;
    private int age;
    
    public User() {
        this.name = "";
        this.age = 0;
    }
}
```

**検出結果**:
- 型: `constructor`
- メソッド名: `User`
- 戻り値の型: （なし）
- 修飾子: `public`
- 引数: `[]`

---

#### 2.2 パラメータ付きコンストラクタ

引数を受け取ってインスタンスを初期化するコンストラクタ。

```java
public class User {
    private String name;
    private int age;
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

**検出結果**:
- 型: `constructor`
- メソッド名: `User`
- 戻り値の型: （なし）
- 修飾子: `public`
- 引数: `['String name', 'int age']`

---

#### 2.3 プライベートコンストラクタ

シングルトンパターンなどで使用されるプライベートコンストラクタ。

```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {
        // プライベートコンストラクタ
    }
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**検出結果**:
- 型: `constructor`
- メソッド名: `Singleton`
- 戻り値の型: （なし）
- 修飾子: `private`
- 引数: `[]`

---

#### 2.4 コンストラクタのオーバーロード

複数のコンストラクタを定義して、異なる方法でインスタンスを初期化できます。

```java
public class Rectangle {
    private int width;
    private int height;
    
    public Rectangle() {
        this.width = 0;
        this.height = 0;
    }
    
    public Rectangle(int size) {
        this.width = size;
        this.height = size;
    }
    
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

**検出結果**:
- 1つ目のコンストラクタ: 型=`constructor`, 引数=`[]`
- 2つ目のコンストラクタ: 型=`constructor`, 引数=`['int size']`
- 3つ目のコンストラクタ: 型=`constructor`, 引数=`['int width', 'int height']`

---

#### 2.5 コンストラクタチェーン

`this()`を使用して他のコンストラクタを呼び出すコンストラクタ。

```java
public class Person {
    private String name;
    private int age;
    private String email;
    
    public Person(String name) {
        this(name, 0);
    }
    
    public Person(String name, int age) {
        this(name, age, "");
    }
    
    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
}
```

**検出結果**:
- 3つのコンストラクタが検出されます

---

### 特徴
- ✅ クラス名と同じ名前
- ✅ 戻り値の型がない
- ✅ 修飾子は`public`, `private`, `protected`のみ
- ✅ オーバーロード可能
- ✅ 明示的に定義しない場合、デフォルトコンストラクタが自動生成される

---

## 3. インターフェースメソッド（Interface Method）

### 概要
Java 8以降で導入された、インターフェース内で実装を持つメソッド。`default`メソッドと`static`メソッドがあります。

### 構文
```java
// デフォルトメソッド
default 戻り値の型 メソッド名(引数) {
    // 実装
}

// 静的メソッド
static 戻り値の型 メソッド名(引数) {
    // 実装
}
```

### 検出パターン
- **正規表現**: `r'(?:default|static)\s+(void|[\w<>\[\]\s,\.]+?)\s+(\w+)\s*\(([^)]*)\)\s*\{'`
- **検出される型**: `interface_method`

### 使用される場合

#### 3.1 デフォルトメソッド（Default Method）

インターフェースにデフォルト実装を提供するメソッド。実装クラスでオーバーライド可能です。

```java
public interface Calculator {
    int add(int a, int b);
    
    default int subtract(int a, int b) {
        return a - b;
    }
    
    default void printResult(int result) {
        System.out.println("Result: " + result);
    }
}

public class BasicCalculator implements Calculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }
    
    // subtractとprintResultはデフォルト実装を使用
}
```

**検出結果**:
- `subtract`: 型=`interface_method`, 戻り値の型=`int`, 修飾子=`default`, 引数=`['int a', 'int b']`
- `printResult`: 型=`interface_method`, 戻り値の型=`void`, 修飾子=`default`, 引数=`['int result']`

---

#### 3.2 静的メソッド（Static Method）

インターフェース内で定義される静的メソッド。インターフェース名で直接呼び出せます。

```java
public interface MathUtils {
    static int add(int a, int b) {
        return a + b;
    }
    
    static double calculateAverage(double[] numbers) {
        double sum = 0;
        for (double num : numbers) {
            sum += num;
        }
        return sum / numbers.length;
    }
}

// 使用例
int result = MathUtils.add(5, 3);
double avg = MathUtils.calculateAverage(new double[]{1.0, 2.0, 3.0});
```

**検出結果**:
- `add`: 型=`interface_method`, 戻り値の型=`int`, 修飾子=`static`, 引数=`['int a', 'int b']`
- `calculateAverage`: 型=`interface_method`, 戻り値の型=`double`, 修飾子=`static`, 引数=`['double[] numbers']`

---

#### 3.3 デフォルトメソッドと静的メソッドの組み合わせ

インターフェース内で両方のタイプのメソッドを定義できます。

```java
public interface DataProcessor {
    void process(String data);
    
    default void processWithDefault(String data) {
        System.out.println("Processing: " + data);
        process(data);
    }
    
    static DataProcessor create() {
        return new DataProcessor() {
            @Override
            public void process(String data) {
                // 実装
            }
        };
    }
}
```

**検出結果**:
- `processWithDefault`: 型=`interface_method`, 戻り値の型=`void`, 修飾子=`default`, 引数=`['String data']`
- `create`: 型=`interface_method`, 戻り値の型=`DataProcessor`, 修飾子=`static`, 引数=`[]`

---

#### 3.4 複数のデフォルトメソッド

インターフェース内で複数のデフォルトメソッドを定義できます。

```java
public interface Logger {
    void log(String message);
    
    default void logInfo(String message) {
        log("[INFO] " + message);
    }
    
    default void logError(String message) {
        log("[ERROR] " + message);
    }
    
    default void logWarning(String message) {
        log("[WARNING] " + message);
    }
}
```

**検出結果**:
- 3つのデフォルトメソッドが検出されます

---

### 特徴
- ✅ Java 8以降で使用可能
- ✅ デフォルトメソッドは実装クラスでオーバーライド可能
- ✅ 静的メソッドはインターフェース名で直接呼び出し可能
- ✅ インターフェースの進化を可能にする（後方互換性）

---

## パターン比較表

| パターン | 戻り値の型 | 修飾子の制限 | 主な用途 |
|---------|----------|------------|---------|
| 通常のメソッド | 必須 | 任意の組み合わせ | クラスの機能実装 |
| コンストラクタ | なし | public/private/protected | インスタンス初期化 |
| インターフェースメソッド | 必須 | default/static | インターフェースの実装提供 |

---

## 検出されないパターン

以下のパターンは現在のツールでは検出されません：

### 1. ラムダ式
```java
// 検出されない
Runnable r = () -> System.out.println("Hello");
Function<String, Integer> f = s -> s.length();
```

### 2. メソッド参照
```java
// 検出されない
List<String> list = Arrays.asList("a", "b", "c");
list.forEach(System.out::println);
```

### 3. アノテーション
```java
// メソッドは検出されるが、アノテーション情報は取得されない
@Override
@Deprecated
public void oldMethod() { }
```

### 4. ネストされたクラス内のメソッド
```java
// 外側のクラスのメソッドは検出されるが、ネストされたクラスとの関係は取得されない
public class Outer {
    public void outerMethod() { }
    
    public class Inner {
        public void innerMethod() { }  // これも検出されるが、Innerクラスとの関係は不明
    }
}
```

---

## まとめ

このツールは、Javaで使用される主要なメソッド定義パターンを検出できます。各パターンにはそれぞれ適した用途があり、プロジェクトの要件に応じて適切なパターンを選択することが重要です。

パターンの選択時には、以下の点を考慮してください：
- アクセス制御の必要性
- インスタンスメソッドか静的メソッドか
- オーバーライドの可能性
- インターフェースの実装
- マルチスレッド環境での安全性

